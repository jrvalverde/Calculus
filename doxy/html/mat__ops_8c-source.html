<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>mat_ops.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="annotated.html">Data Structures</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Data Fields</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><h1>mat_ops.c</h1><a href="mat__ops_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/**</span>
00002 <span class="comment"> *  @file mat_ops.c</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> *  @brief 2D-matrix and elements basic operations.</span>
00005 <span class="comment"> *</span>
00006 <span class="comment"> *  This module implements basic operations on 2D matrices: assignment</span>
00007 <span class="comment"> *  of one matrix contents to another, computing the transpose and the</span>
00008 <span class="comment"> *  inverse.</span>
00009 <span class="comment"> *</span>
00010 <span class="comment"> *  @pre    portable.h</span>
00011 <span class="comment"> *</span>
00012 <span class="comment"> *  @pre    matrix.h</span>
00013 <span class="comment"> *</span>
00014 <span class="comment"> *  @see    matrix.h for a general introduction to matrices</span>
00015 <span class="comment"> *</span>
00016 <span class="comment"> *  @see    mat_housekeep.c to learn how to create/destroy matrices</span>
00017 <span class="comment"> *          before using this module.</span>
00018 <span class="comment"> *</span>
00019 <span class="comment"> *  @see    mat_init.c to learn how you can assign initial values to</span>
00020 <span class="comment"> *          a matrix or its elements.</span>
00021 <span class="comment"> *</span>
00022 <span class="comment"> *  @see    mat_arith.c to learn more about how to perform basic</span>
00023 <span class="comment"> *          matrix arithmetic.</span>
00024 <span class="comment"> *</span>
00025 <span class="comment"> *  @author José Ramón Valverde Carrillo    (jrvalverde@acm.org)</span>
00026 <span class="comment"> *</span>
00027 <span class="comment"> *  @version    3.0</span>
00028 <span class="comment"> *</span>
00029 <span class="comment"> *  @date   23 - february - 2004    v3.0</span>
00030 <span class="comment"> *</span>
00031 <span class="comment"> *  @date   11 - february - 2004    v2.0</span>
00032 <span class="comment"> *</span>
00033 <span class="comment"> *  @date    1 - october - 1988     Last modification of v1.0</span>
00034 <span class="comment"> *</span>
00035 <span class="comment"> *      COPYRIGHT:</span>
00036 <span class="comment"> *          © YoEgo.    Since I have no cash, I can't</span>
00037 <span class="comment"> *      register this (nor do I believe I should). So</span>
00038 <span class="comment"> *      this module is left in the PUBLIC DOMAIN.</span>
00039 <span class="comment"> *          It is furthermore forbidden its use for</span>
00040 <span class="comment"> *      commercial purposes unless I get a share on</span>
00041 <span class="comment"> *      the profits.</span>
00042 <span class="comment"> *          I say.</span>
00043 <span class="comment"> *                                              YoEgo.</span>
00044 <span class="comment"> *</span>
00045 <span class="comment"> * $Id$</span>
00046 <span class="comment"> * $Log$</span>
00047 <span class="comment"> */</span>
00048 
00049 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00050 <span class="preprocessor">#include &lt;math.h&gt;</span>
00051 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00052 <span class="preprocessor">#include &lt;bits/nan.h&gt;</span>
00053 
00054 <span class="preprocessor">#include "<a class="code" href="portable_8h.html">portable.h</a>"</span>
00055 <span class="preprocessor">#include "<a class="code" href="matrix_8h.html">matrix.h</a>"</span>
00056 
00057 
00058 
00059 <span class="comment">/*----------------------------------------------------------------*/</span>
00060 <span class="comment">/*                      MATRIX OPERATIONS                         */</span>
00061 <span class="comment">/*----------------------------------------------------------------*/</span>
00062 <span class="comment"></span>
00063 <span class="comment">/** @defgroup matrix_operations</span>
00064 <span class="comment"> *  @{</span>
00065 <span class="comment"> */</span>
00066 <span class="comment"></span>
00067 <span class="comment">/**</span>
00068 <span class="comment"> * @brief MAT dest = orig</span>
00069 <span class="comment"> *</span>
00070 <span class="comment"> * Transfer ([m] x [n]) elements from 2 to 1.</span>
00071 <span class="comment"> *</span>
00072 <span class="comment"> * Assigns the values of one matrix to another. Both matrices must have</span>
00073 <span class="comment"> * the same dimensions, otherwise an error result will occur.</span>
00074 <span class="comment"> *</span>
00075 <span class="comment"> * If the origin matrix is NULL, then the destination matrix will be</span>
00076 <span class="comment"> * set to the null matrix (i.e. all of its elements initialized to zero).</span>
00077 <span class="comment"> *</span>
00078 <span class="comment"> * @param dest  the destination matrix</span>
00079 <span class="comment"> * @param orig  the origin matrix</span>
00080 <span class="comment"> *</span>
00081 <span class="comment"> * @return SUCCESS if all went well, an error code otherwise</span>
00082 <span class="comment"> *</span>
00083 <span class="comment"> */</span>
<a name="l00084"></a><a class="code" href="mat__ops_8c.html#a0">00084</a> <span class="keyword">public</span> <a class="code" href="portable_8h.html#a78">status</a> <a class="code" href="mat__ops_8c.html#a0">mat_assign</a>(<a class="code" href="structmatrix.html">matrix</a> dest, <a class="code" href="structmatrix.html">matrix</a> orig)
00085 {
00086 <span class="preprocessor">#ifndef MAT_OPTIMIZE</span>
00087 <span class="preprocessor"></span>    <span class="keyword">register</span> <span class="keywordtype">int</span> i, j, maxrow, maxcol;
00088     <a class="code" href="matrix_8h.html#a5">real</a> **val1, **val2;
00089 <span class="preprocessor">#else</span>
00090 <span class="preprocessor"></span>    <span class="keyword">register</span> <span class="keywordtype">int</span> i, size;
00091     <a class="code" href="matrix_8h.html#a5">real</a> *element1;
00092     <a class="code" href="matrix_8h.html#a5">real</a> *element2;
00093 
00094 <span class="preprocessor">#endif</span>
00095 <span class="preprocessor"></span>
00096     <span class="keywordflow">if</span> (orig == NULL)
00097         <span class="keywordflow">return</span> <a class="code" href="mat__init_8c.html#a1">mat_init</a>(dest, 0.0);
00098 
00099 <span class="preprocessor">#ifdef MAT_PARANOIA</span>
00100 <span class="preprocessor"></span>    <span class="keywordflow">if</span> ((dest-&gt;<a class="code" href="structmatrix.html#m0">rows</a> != orig-&gt;<a class="code" href="structmatrix.html#m0">rows</a>) || (dest-&gt;<a class="code" href="structmatrix.html#m1">cols</a> != orig-&gt;<a class="code" href="structmatrix.html#m1">cols</a>))
00101         <span class="keywordflow">return</span> <a class="code" href="matrix_8h.html#a2">MAT_BOUNDSCHECK</a>;
00102 <span class="preprocessor">#endif</span>
00103 <span class="preprocessor"></span>
00104 <span class="preprocessor">#ifndef MAT_OPTIMIZE</span>
00105 <span class="preprocessor"></span>    maxrow = dest-&gt;<a class="code" href="structmatrix.html#m0">rows</a>;
00106     maxcol = dest-&gt;<a class="code" href="structmatrix.html#m1">cols</a>;
00107     val1 = dest-&gt;<a class="code" href="structmatrix.html#m2">values</a>;
00108     val2 = orig-&gt;<a class="code" href="structmatrix.html#m2">values</a>;
00109     <span class="keywordflow">for</span> (i = 1; i &lt;= maxrow; i++)
00110         <span class="keywordflow">for</span> (j = 1; j &lt;= maxcol; j++)
00111             val1[i][j] = val2[i][j];
00112 <span class="preprocessor">#else</span>
00113 <span class="preprocessor"></span>    <span class="comment">/* we know all values are stored contiguously after mat-&gt;values[1][1] */</span>
00114     size = dest-&gt;<a class="code" href="structmatrix.html#m0">rows</a> * dest-&gt;<a class="code" href="structmatrix.html#m1">cols</a>;
00115     element1 = dest-&gt;<a class="code" href="structmatrix.html#m2">values</a>[1];
00116     element2 = orig-&gt;<a class="code" href="structmatrix.html#m2">values</a>[1];
00117     <span class="keywordflow">for</span> (i = 1; i &lt;= size; i++) {
00118         <span class="comment">/* element1[i] = element2[i]; */</span>
00119         *element1 = *element2;
00120         element1++;
00121         element2++;
00122     }
00123 <span class="preprocessor">#endif</span>
00124 <span class="preprocessor"></span>    <span class="keywordflow">return</span> <a class="code" href="portable_8h.html#a65">SUCCESS</a>;
00125 }
00126 <span class="comment"></span>
00127 <span class="comment">/**</span>
00128 <span class="comment"> * @brief MAT trn = TRN(mat)</span>
00129 <span class="comment"> *        Compute the transpose of a matrix</span>
00130 <span class="comment"> *</span>
00131 <span class="comment"> * The transpose A&lt;sup&gt;T&lt;/sup&gt; of a matrix A is</span>
00132 <span class="comment"> * A' = A&lt;sup&gt;T&lt;/sup&gt; / row A' = col A =&gt;                </span>
00133 <span class="comment"> *</span>
00134 <span class="comment"> *  (A)&lt;sub&gt;ij&lt;/sub&gt; = (A&lt;sup&gt;T&lt;/sup&gt;)&lt;sub&gt;ji&lt;/sub&gt;      </span>
00135 <span class="comment"> *</span>
00136 <span class="comment"> * Thus, if A&lt;sub&gt;m·n&lt;/sub&gt;, then A'&lt;sub&gt;n.m&lt;/sub&gt; =&gt;    </span>
00137 <span class="comment"> *</span>
00138 <span class="comment"> *  If A · B = C -&gt; C' = A' · B'                         </span>
00139 <span class="comment"> *</span>
00140 <span class="comment"> * We may therefore describe a column vector as a row vector</span>
00141 <span class="comment"> *</span>
00142 <span class="comment"> @f[</span>
00143 <span class="comment"> \pmatrix {</span>
00144 <span class="comment">    x_1 \cr</span>
00145 <span class="comment">    x_2 \cr</span>
00146 <span class="comment">    \cdots \cr</span>
<a name="l00147"></a><a class="code" href="mat__ops_8c.html#a1">00147</a> <span class="comment">    x_{n-1} \cr</span>
00148 <span class="comment">    x_n \cr</span>
00149 <span class="comment">    } = \pmatrix {x_1 &amp; x_2 &amp; \cdots &amp; x_n \cr }</span>
00150 <span class="comment"> @f]</span>
00151 <span class="comment"> *</span>
00152 <span class="comment"> * @param trn   a matrix where we will store the transpose</span>
00153 <span class="comment"> * @param mat   the matrix whose transpose we want to take</span>
00154 <span class="comment"> */</span>
00155 <span class="keyword">public</span> <a class="code" href="portable_8h.html#a78">status</a> <a class="code" href="mat__ops_8c.html#a1">mat_transpose</a>(<a class="code" href="structmatrix.html">matrix</a> trn, <a class="code" href="structmatrix.html">matrix</a> mat)
00156 {
00157 
00158     <span class="keyword">register</span> <span class="keywordtype">int</span> i, j;
00159 
00160 <span class="preprocessor">#   ifdef MAT_PARANOIA</span>
00161 <span class="preprocessor"></span>    <span class="comment">/* Check dimensions */</span>
00162     <span class="keywordflow">if</span> ((trn-&gt;<a class="code" href="structmatrix.html#m0">rows</a> != mat-&gt;<a class="code" href="structmatrix.html#m1">cols</a>) || (trn-&gt;<a class="code" href="structmatrix.html#m1">cols</a> != mat-&gt;<a class="code" href="structmatrix.html#m0">rows</a>))
00163         <span class="keywordflow">return</span> <a class="code" href="matrix_8h.html#a2">MAT_BOUNDSCHECK</a>;
00164 <span class="preprocessor">#   endif</span>
00165 <span class="preprocessor"></span>
00166 <span class="preprocessor">#   ifndef MAT_OPTIMIZE</span>
00167 <span class="preprocessor"></span>    <span class="keywordflow">for</span> (i = 1; i &lt;= mat-&gt;<a class="code" href="structmatrix.html#m0">rows</a>; i++)
00168         <span class="keywordflow">for</span> (j = 1; j &lt;= mat-&gt;<a class="code" href="structmatrix.html#m1">cols</a>; j++)
00169             trn-&gt;<a class="code" href="structmatrix.html#m2">values</a>[j][i] = mat-&gt;<a class="code" href="structmatrix.html#m2">values</a>[i][j];
00170 <span class="preprocessor">#   else</span>
00171 <span class="preprocessor"></span>    <span class="comment">/* we know all elements are stored contiguously */</span>
00172     {
00173         <span class="keywordtype">int</span> i, size;
00174         <a class="code" href="matrix_8h.html#a5">real</a> *trn_elem;
00175         <a class="code" href="matrix_8h.html#a5">real</a> *mat_elem;
00176 
00177         size = mat-&gt;<a class="code" href="structmatrix.html#m0">rows</a> * mat-&gt;<a class="code" href="structmatrix.html#m1">cols</a>;
00178         trn_elem = trn-&gt;<a class="code" href="structmatrix.html#m2">values</a>[1] + size;
00179         mat_elem = mat-&gt;<a class="code" href="structmatrix.html#m2">values</a>[1];
00180         <span class="keywordflow">for</span> (i = 1; i &lt;= size; i++) {
00181             <span class="comment">/* trn_elem[size - i + 1] = mat_elem[size] */</span>
00182             *trn_elem = *mat_elem;
00183             trn_elem--;
00184             mat_elem++;
00185         }
00186     }
00187 <span class="preprocessor">#   endif</span>
00188 <span class="preprocessor"></span>    <span class="keywordflow">return</span> <a class="code" href="portable_8h.html#a65">SUCCESS</a>;
00189 }
00190 
00191 <span class="comment"></span>
00192 <span class="comment">/**</span>
00193 <span class="comment"> * @brief MAT B = INV ( C );</span>
00194 <span class="comment"> *</span>
00195 <span class="comment"> *   Computes the inverted matrix of C, which is a square matrix n x n</span>
00196 <span class="comment"> *   and stores the result on B.</span>
00197 <span class="comment"> *   The algorithm employed is a modification of Gauss' method. This</span>
00198 <span class="comment"> *   is probably not the best (nor is it the nicest implementation),</span>
00199 <span class="comment"> *   but for the moment will do.</span>
00200 <span class="comment"> *</span>
00201 <span class="comment"> *   Given the identity matrix I&lt;sub&gt;nn&lt;/sub&gt;, we may think of another</span>
00202 <span class="comment"> *   such that</span>
00203 <span class="comment"> *</span>
00204 <span class="comment"> *  A B = B A = I =&gt; B = A&lt;sup&gt;-1&lt;/sup&gt;</span>
00205 <span class="comment"> *</span>
00206 <span class="comment"> *  A A&lt;sup&gt;-1&lt;/sup&gt; = I = A&lt;sup&gt;-1&lt;/sup&gt; A</span>
00207 <span class="comment"> *</span>
00208 <span class="comment"> *   Using the cofactors of A&lt;sub&gt;ij&lt;/sub&gt; we may compute</span>
00209 <span class="comment"> *</span>
00210 <span class="comment"> *  A&lt;sup&gt;-1&lt;/sup&gt; = 1 / |A| · adj(A)</span>
00211 <span class="comment"> *</span>
00212 <span class="comment"> *   (calculating through the adjunct matrix). If |A| = 0 then it is not</span>
00213 <span class="comment"> *  defined and A is SINGULAR.</span>
00214 <span class="comment"> *   </span>
00215 <span class="comment"> *   The inverse of a matrix A, if it exists, is unique and may be</span>
00216 <span class="comment"> *   found:</span>
00217 <span class="comment"> *   We first form for A&lt;sub&gt;nn&lt;/sub&gt; the matrix A&lt;sub&gt;n x 2n&lt;/sub&gt;</span>
00218 <span class="comment"> *   @f[ (A, I) = \pmatrix {</span>
00219 <span class="comment">        a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} &amp; 1 &amp; 0 &amp; \cdots &amp; 0 \cr</span>
00220 <span class="comment">        a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n} &amp; 0 &amp; 1 &amp; \cdots &amp; 0  \cr</span>
00221 <span class="comment">        \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; 0  \cr</span>
00222 <span class="comment">        a_{n1} &amp; a_{n2} &amp; \cdots &amp; a_{nn} &amp; 0 &amp; 0 &amp; \cdots &amp; 1  \cr }</span>
00223 <span class="comment">     @f]</span>
<a name="l00224"></a><a class="code" href="mat__ops_8c.html#a2">00224</a> <span class="comment"> *   That is, the left half is A and the right half I, the identity</span>
00225 <span class="comment"> *   matrix. Using a modified Gauss method we transform the former</span>
00226 <span class="comment"> *   matrix into</span>
00227 <span class="comment"> *   @f[ (I, B) =</span>
00228 <span class="comment">  \pmatrix {</span>
00229 <span class="comment">    1      &amp; 0      &amp; \cdots &amp; 0    &amp;   b_{11} &amp; b_{12} &amp; \cdots &amp; b_{1n}\cr</span>
00230 <span class="comment">    0      &amp; 1      &amp; \cdots &amp; 0    &amp;   b_{21} &amp; b_{22} &amp; \cdots &amp; b_{2n}\cr</span>
00231 <span class="comment">    \vdots &amp; \vdots &amp; \ddots &amp; 0    &amp;   \vdots &amp; \vdots &amp; \ddots &amp; \vdots\cr</span>
00232 <span class="comment">    0      &amp; 0      &amp; \cdots &amp; 1    &amp;   b_{n1} &amp; b_{n2} &amp; \cdots &amp; b_{nn}\cr }</span>
00233 <span class="comment">     @f]</span>
00234 <span class="comment"> *   Now the left half is I and the right half, B is the inverse of A.</span>
00235 <span class="comment"> *</span>
00236 <span class="comment"> *   To avoid changing matrix C we get first a working copy that</span>
00237 <span class="comment"> *   we store in matrix A, whose space is reserved ex-profeso and</span>
00238 <span class="comment"> *   is freed upon termination.</span>
00239 <span class="comment"> *</span>
00240 <span class="comment"> * @callgraph</span>
00241 <span class="comment"> */</span>
00242 
00243 <span class="keyword">public</span> <a class="code" href="portable_8h.html#a78">status</a> <a class="code" href="mat__ops_8c.html#a2">mat_invert</a>(<a class="code" href="structmatrix.html">matrix</a> B, <a class="code" href="structmatrix.html">matrix</a> C)
00244                                 <span class="comment">/* matrices inverse and to invert       */</span>
00245                                 <span class="comment">/* both are square matrices n x n       */</span>
00246 {
00247     <span class="keywordtype">int</span> i, j, k, l;             <span class="comment">/* indexes                  */</span>
00248     <span class="keywordtype">int</span> n;                      <span class="comment">/* dimension                */</span>
00249     <a class="code" href="matrix_8h.html#a5">real</a> temp;                  <span class="comment">/* auxiliary variable       */</span>
00250     <a class="code" href="structmatrix.html">matrix</a> A;                   <span class="comment">/* backup matrix            */</span>
00251     <span class="keywordtype">boolean</span> singular = <a class="code" href="portable_8h.html#a59">FALSE</a>;   <span class="comment">/* TRUE if c is singular    */</span>
00252     <a class="code" href="matrix_8h.html#a5">real</a> **a, **b;
00253 
00254     n = B-&gt;<a class="code" href="structmatrix.html#m0">rows</a>;
00255     <a class="code" href="mat__housekeep_8c.html#a0">mat_alloc</a>(&amp;A, n, n);                <span class="comment">/* create A */</span>
00256     <span class="keywordflow">if</span> (A == NULL)              <span class="comment">/* (if we can) */</span>
00257         <span class="keywordflow">return</span> <a class="code" href="matrix_8h.html#a1">MAT_NOMEMORY</a>;
00258     <a class="code" href="mat__ops_8c.html#a0">mat_assign</a>(A, C);           <span class="comment">/* copy C into A to avoid changing it */</span>
00259 
00260     <span class="comment">/* make B equal the identity matrix */</span>
00261     <a class="code" href="mat__init_8c.html#a2">mat_identity</a>(B);
00262 
00263     a = A-&gt;<a class="code" href="structmatrix.html#m2">values</a>;
00264     b = B-&gt;<a class="code" href="structmatrix.html#m2">values</a>;
00265     
00266     <span class="keywordflow">for</span> (j = 1; j &lt;= n; j++) {
00267         <span class="keywordflow">for</span> (i = j; i &lt;= n; i++)
00268             <span class="keywordflow">if</span> (a[i][j] != 0)           <span class="comment">/* is it singular ?        */</span>
00269                 <span class="keywordflow">goto</span> __Compute__;       <span class="comment">/* NO                      */</span>
00270             <span class="comment">/* The matrix is singular, EXIT */</span>
00271             <a class="code" href="mat__housekeep_8c.html#a1">mat_free</a>(A);
00272             <span class="keywordflow">return</span> <a class="code" href="matrix_8h.html#a3">MAT_SINGULAR</a>;
00273 
00274       __Compute__:
00275         <span class="keywordflow">for</span> (k = 1; k &lt;= n; k++) {
00276             <span class="comment">/* swap a[j][k] and a[i][k] */</span>
00277             temp = a[j][k];
00278             a[j][k] = a[i][k];
00279             a[i][k] = temp;
00280 
00281             <span class="comment">/* swap inv[j][k] and inv[i][k] */</span>
00282             temp = b[j][k];
00283             b[j][k] = b[i][k];
00284             b[i][k] = temp;
00285         }                       <span class="comment">/* K */</span>
00286 
00287         temp = 1 / a[j][j];
00288         <span class="keywordflow">for</span> (k = 1; k &lt;= n; k++) {
00289             a[j][k] *= temp;
00290             b[j][k] *= temp;
00291         }                       <span class="comment">/* K */</span>
00292 
00293         <span class="keywordflow">for</span> (l = 1; l &lt;= n; l++) {
00294             <span class="keywordflow">if</span> (l != j) {
00295                 temp = -a[l][j];
00296                 <span class="keywordflow">for</span> (k = 1; k &lt;= n; k++) {
00297                     a[l][k] += (temp * a[j][k]);
00298 
00299                     b[l][k] += (temp * b[j][k]);
00300                 }               <span class="comment">/* K */</span>
00301             }                   <span class="comment">/* IF */</span>
00302         }                       <span class="comment">/* L */</span>
00303     }                           <span class="comment">/* J */</span>
00304     <span class="comment">/* B = inverse of C                     */</span>
00305     <span class="comment">/* A is no longer needed, kiss it good bye.  */</span>
00306     <a class="code" href="mat__housekeep_8c.html#a1">mat_free</a>(A);
00307     <span class="keywordflow">if</span> (singular == <a class="code" href="portable_8h.html#a58">TRUE</a>)
00308         <span class="keywordflow">return</span> (MAT_SINGULAR);  <span class="comment">/* so sorry     */</span>
00309     <span class="keywordflow">else</span>
00310         <span class="keywordflow">return</span> (SUCCESS);       <span class="comment">/* happy end    */</span>
00311 }
00312 <span class="comment"></span>
00313 <span class="comment">/** @} */</span>
</pre></div><hr><address style="align: right;"><small>Generated on Fri Mar 5 19:26:48 2004 for MATRIXCALCULUS by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.18 </small></address>
</body>
</html>
