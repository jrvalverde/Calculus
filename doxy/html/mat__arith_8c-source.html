<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>mat_arith.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="annotated.html">Data Structures</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Data Fields</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><h1>mat_arith.c</h1><a href="mat__arith_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/**</span>
00002 <span class="comment"> *</span>
00003 <span class="comment"> *  @file   mat_arith.c</span>
00004 <span class="comment"> *</span>
00005 <span class="comment"> *  @brief  Basic arithmetic operations with matrices.</span>
00006 <span class="comment"> *</span>
00007 <span class="comment"> *  An implementation of marix arithmetics. This module includes functions</span>
00008 <span class="comment"> *  to perform matrix summation, substraction, multiplication and computing</span>
00009 <span class="comment"> *  the scalar product. These operations are base to more advanced matrix</span>
00010 <span class="comment"> *  calculus manipulations.</span>
00011 <span class="comment"> *</span>
00012 <span class="comment"> *  @pre    portable.h</span>
00013 <span class="comment"> *</span>
00014 <span class="comment"> *  @pre    matrix.h</span>
00015 <span class="comment"> *</span>
00016 <span class="comment"> *  @see    matrix.h for a general introduction to matrices</span>
00017 <span class="comment"> *</span>
00018 <span class="comment"> *  @see    mat_init.c to learn how you can assign initial values to</span>
00019 <span class="comment"> *          a matrix or its elements.</span>
00020 <span class="comment"> *</span>
00021 <span class="comment"> *  @see    mat_ops.c   to learn more about how to perform basic</span>
00022 <span class="comment"> *          matrix operations.</span>
00023 <span class="comment"> *</span>
00024 <span class="comment"> *  @see    mat_test.c      Is an auxiliary module with</span>
00025 <span class="comment"> *          the test code of these functions used to debug this</span>
00026 <span class="comment"> *          module (last time everything went OK).</span>
00027 <span class="comment"> *</span>
00028 <span class="comment"> *  @author José Ramón Valverde Carrillo    (jrvalverde@acm.org)</span>
00029 <span class="comment"> *</span>
00030 <span class="comment"> *  @version    3.0</span>
00031 <span class="comment"> *</span>
00032 <span class="comment"> *  @date   23 - february - 2004    v3.0</span>
00033 <span class="comment"> *</span>
00034 <span class="comment"> *  @date   11 - february - 2004    v2.0</span>
00035 <span class="comment"> *</span>
00036 <span class="comment"> *  @date    1 - october - 1988     Last modification of v1.0</span>
00037 <span class="comment"> *</span>
00038 <span class="comment"> *      COPYRIGHT:</span>
00039 <span class="comment"> *          © YoEgo.    Since I have no cash, I can't</span>
00040 <span class="comment"> *      register this (nor do I believe I should). So</span>
00041 <span class="comment"> *      this module is left in the PUBLIC DOMAIN.</span>
00042 <span class="comment"> *          It is furthermore forbidden its use for</span>
00043 <span class="comment"> *      commercial purposes unless I get a share on</span>
00044 <span class="comment"> *      the profits.</span>
00045 <span class="comment"> *          I say.</span>
00046 <span class="comment"> *                                              YoEgo.</span>
00047 <span class="comment"> *</span>
00048 <span class="comment"> * $Id$</span>
00049 <span class="comment"> * $Log$</span>
00050 <span class="comment"> */</span>
00051 
00052 
00053 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00054 <span class="preprocessor">#include &lt;math.h&gt;</span>
00055 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00056 <span class="preprocessor">#include &lt;bits/nan.h&gt;</span>
00057 
00058 <span class="preprocessor">#include "<a class="code" href="portable_8h.html">portable.h</a>"</span>
00059 <span class="preprocessor">#include "<a class="code" href="matrix_8h.html">matrix.h</a>"</span>
00060 
00061 
00062 
00063 
00064 <span class="comment">/*----------------------------------------------------------------*/</span>
00065 <span class="comment">/*                      MATRIX ARITHMETIC                         */</span>
00066 <span class="comment">/*----------------------------------------------------------------*/</span>
00067 <span class="comment"></span>
00068 <span class="comment">/** \defgroup matrix_arithmetic</span>
00069 <span class="comment"> * @{</span>
00070 <span class="comment"> */</span>
00071  
00072 <span class="comment"></span>
00073 <span class="comment">/** </span>
00074 <span class="comment"> * \brief MAT C = A + B;</span>
00075 <span class="comment"> *</span>
00076 <span class="comment"> *  sum two matrices and store result in another.</span>
00077 <span class="comment"> *</span>
00078 <span class="comment"> *  function mat_sum adds two matrices and stores the result in a</span>
00079 <span class="comment"> *  separate one. Both matrices must have the same number of rows</span>
00080 <span class="comment"> *  and columns:</span>
00081 <span class="comment"> *</span>
00082 <span class="comment"> *  \f[</span>
00083 <span class="comment">    \sum A_{mn} + B_{mn} = C_{mn} / c_{ij} = a_{ij} + b_{ij} </span>
00084 <span class="comment">    (i = 1 \ldots m, j = 1 \ldots n)</span>
00085 <span class="comment">    \f]</span>
00086 <span class="comment"> *</span>
00087 <span class="comment"> * \param result    a matrix to store the sum</span>
00088 <span class="comment"> * \param mat1      sumand</span>
00089 <span class="comment"> * \param mat2      sumand</span>
00090 <span class="comment"> *</span>
<a name="l00091"></a><a class="code" href="mat__arith_8c.html#a0">00091</a> <span class="comment"> *  \return SUCCESS if all went well, an error code otherwise</span>
00092 <span class="comment"> *</span>
00093 <span class="comment"> */</span>
00094 <span class="keyword">public</span> <a class="code" href="portable_8h.html#a78">status</a> <a class="code" href="mat__arith_8c.html#a0">mat_sum</a>(<a class="code" href="structmatrix.html">matrix</a> result, <a class="code" href="structmatrix.html">matrix</a> mat1, <a class="code" href="structmatrix.html">matrix</a> mat2)
00095 {
00096 <span class="preprocessor">#   ifdef MAT_PARANOIA</span>
00097 <span class="preprocessor"></span>    <span class="comment">/* check bounds */</span>
00098     <span class="keywordflow">if</span> ((result-&gt;<a class="code" href="structmatrix.html#m0">rows</a> != mat1-&gt;<a class="code" href="structmatrix.html#m0">rows</a>) || (mat1-&gt;<a class="code" href="structmatrix.html#m0">rows</a> != mat2-&gt;<a class="code" href="structmatrix.html#m0">rows</a>) ||
00099         (result-&gt;<a class="code" href="structmatrix.html#m1">cols</a> != mat1-&gt;<a class="code" href="structmatrix.html#m1">cols</a>) || (mat1-&gt;<a class="code" href="structmatrix.html#m1">cols</a> != mat2-&gt;<a class="code" href="structmatrix.html#m1">cols</a>))
00100         <span class="keywordflow">return</span> <a class="code" href="matrix_8h.html#a2">MAT_BOUNDSCHECK</a>;
00101 <span class="preprocessor">#   endif</span>
00102 <span class="preprocessor"></span>
00103 <span class="preprocessor">#ifndef MAT_OPTIMIZE</span>
00104 <span class="preprocessor"></span>    {
00105         <span class="keyword">register</span> <span class="keywordtype">int</span> i, j;
00106         <a class="code" href="matrix_8h.html#a5">real</a> **sum, **val1, **val2;
00107 
00108         sum = result-&gt;<a class="code" href="structmatrix.html#m2">values</a>;
00109         val1 = mat1-&gt;<a class="code" href="structmatrix.html#m2">values</a>;
00110         val2 = mat2-&gt;<a class="code" href="structmatrix.html#m2">values</a>;
00111         <span class="keywordflow">for</span> (i = 1; i &lt;= result-&gt;<a class="code" href="structmatrix.html#m0">rows</a>; i++)
00112             <span class="keywordflow">for</span> (j = 1; j &lt;= result-&gt;<a class="code" href="structmatrix.html#m1">cols</a>; j++)
00113                 sum[i][j] = val1[i][j] + val2[i][j];
00114     }
00115 <span class="preprocessor">#else</span>
00116 <span class="preprocessor"></span>    {
00117         <span class="comment">/* we know elements are stored contiguously, hence we can</span>
00118 <span class="comment">           treat is as unidimensional as well, saving on indirections */</span>
00119         <span class="keyword">register</span> <span class="keywordtype">int</span> i, size;
00120         <a class="code" href="matrix_8h.html#a5">real</a> *res, *elem1, *elem2;
00121 
00122         size = result-&gt;<a class="code" href="structmatrix.html#m0">rows</a> * result-&gt;<a class="code" href="structmatrix.html#m1">cols</a>;
00123         res = result-&gt;<a class="code" href="structmatrix.html#m2">values</a>[1];
00124         elem1 = mat1-&gt;<a class="code" href="structmatrix.html#m2">values</a>[1];
00125         elem2 = mat2-&gt;<a class="code" href="structmatrix.html#m2">values</a>[1];
00126             <span class="keywordflow">for</span> (i = 1; i &lt;= size; i++)
00127             res[i] = elem1[i] + elem2[i];
00128     }
00129 <span class="preprocessor">#endif</span>
00130 <span class="preprocessor"></span>    <span class="keywordflow">return</span> <a class="code" href="portable_8h.html#a65">SUCCESS</a>;
00131 }
00132 
00133 <span class="comment"></span>
00134 <span class="comment">/**</span>
00135 <span class="comment"> * \brief MAT res = mat1 - mat2</span>
00136 <span class="comment"> *</span>
00137 <span class="comment"> * Substracts mat2 from mat1 and stores result in res.</span>
00138 <span class="comment"> *</span>
00139 <span class="comment"> *  Subtract one matrix from another and store the result in another one.</span>
00140 <span class="comment"> *  All three matrices must have the same dimensions:</span>
00141 <span class="comment"> *</span>
00142 <span class="comment"> *  \f[ A_{mn} - B_{mn} = E_{mn} / e_{ij} = a_{ij} - b_{ij}</span>
00143 <span class="comment"> *  (i = 1 \ldots m; j = 1 \ldots n) \f]</span>
00144 <span class="comment"> *</span>
00145 <span class="comment"> * \param result        The resulting substraction matrix</span>
00146 <span class="comment"> * \param mat1  Minuend matrix</span>
00147 <span class="comment"> * \param mat2  Substraend matrix</span>
<a name="l00148"></a><a class="code" href="mat__arith_8c.html#a1">00148</a> <span class="comment"> *</span>
00149 <span class="comment"> * \return SUCCESS if all went well, an error code otherwise</span>
00150 <span class="comment"> *</span>
00151 <span class="comment"> */</span>
00152 <span class="keyword">public</span> <a class="code" href="portable_8h.html#a78">status</a> <a class="code" href="mat__arith_8c.html#a1">mat_substract</a>(<a class="code" href="structmatrix.html">matrix</a> result, <a class="code" href="structmatrix.html">matrix</a> mat1, <a class="code" href="structmatrix.html">matrix</a> mat2)
00153 {
00154 <span class="preprocessor">#   ifdef MAT_PARANOIA</span>
00155 <span class="preprocessor"></span>    <span class="comment">/* check bounds */</span>
00156     <span class="keywordflow">if</span> ((result-&gt;<a class="code" href="structmatrix.html#m0">rows</a> != mat1-&gt;<a class="code" href="structmatrix.html#m0">rows</a>) || (mat1-&gt;<a class="code" href="structmatrix.html#m0">rows</a> != mat2-&gt;<a class="code" href="structmatrix.html#m0">rows</a>) ||
00157         (result-&gt;<a class="code" href="structmatrix.html#m1">cols</a> != mat1-&gt;<a class="code" href="structmatrix.html#m1">cols</a>) || (mat1-&gt;<a class="code" href="structmatrix.html#m1">cols</a> != mat2-&gt;<a class="code" href="structmatrix.html#m1">cols</a>))
00158         <span class="keywordflow">return</span> <a class="code" href="matrix_8h.html#a2">MAT_BOUNDSCHECK</a>;
00159 <span class="preprocessor">#   endif</span>
00160 <span class="preprocessor"></span>
00161 <span class="preprocessor">#ifndef MAT_OPTIMIZE</span>
00162 <span class="preprocessor"></span>    {
00163         <span class="keyword">register</span> <span class="keywordtype">int</span> i, j;
00164         <a class="code" href="matrix_8h.html#a5">real</a> **sub, **val1, **val2;
00165 
00166         sub = result-&gt;<a class="code" href="structmatrix.html#m2">values</a>;
00167         val1 = mat1-&gt;<a class="code" href="structmatrix.html#m2">values</a>;
00168         val2 = mat2-&gt;<a class="code" href="structmatrix.html#m2">values</a>;
00169         <span class="keywordflow">for</span> (i = 1; i &lt;= result-&gt;<a class="code" href="structmatrix.html#m0">rows</a>; i++)
00170             <span class="keywordflow">for</span> (j = 1; j &lt;= result-&gt;<a class="code" href="structmatrix.html#m1">cols</a>; j++)
00171                 sub[i][j] = val1[i][j] - val2[i][j];
00172     }
00173 <span class="preprocessor">#else</span>
00174 <span class="preprocessor"></span>    {
00175         <span class="comment">/* we know elements are stored contiguously, hence we can</span>
00176 <span class="comment">           treat is as unidimensional as well, saving on indirections */</span>
00177         <span class="keyword">register</span> <span class="keywordtype">int</span> i, size;
00178         <a class="code" href="matrix_8h.html#a5">real</a> *res, *elem1, *elem2;
00179 
00180         size = result-&gt;<a class="code" href="structmatrix.html#m0">rows</a> * result-&gt;<a class="code" href="structmatrix.html#m1">cols</a>;
00181         res = result-&gt;<a class="code" href="structmatrix.html#m2">values</a>[1];
00182         elem1 = mat1-&gt;<a class="code" href="structmatrix.html#m2">values</a>[1];
00183         elem2 = mat2-&gt;<a class="code" href="structmatrix.html#m2">values</a>[1];
00184             <span class="keywordflow">for</span> (i = 1; i &lt;= size; i++)
00185             res[i] = elem1[i] - elem2[i];
00186     }
00187 <span class="preprocessor">#endif</span>
00188 <span class="preprocessor"></span>    <span class="keywordflow">return</span> <a class="code" href="portable_8h.html#a65">SUCCESS</a>;
00189 }
00190 
00191 <span class="comment"></span>
00192 <span class="comment">/**</span>
00193 <span class="comment"> * \brief   MAT prod[m][p] = fact1[m][n] * fact2[n][p];</span>
00194 <span class="comment"> *  Compute the product of two matrices</span>
00195 <span class="comment"> *</span>
00196 <span class="comment"> * Compute the product of two matrices and store result in another one.</span>
00197 <span class="comment"> * The number of columns in the first factor matrix must be equal to</span>
00198 <span class="comment"> * the number of rows in the second factor matrix. The resulting product </span>
00199 <span class="comment"> * matrix will have same number of rows as first factor and same number</span>
00200 <span class="comment"> * of columns as second factor.</span>
00201 <span class="comment"> *</span>
00202 <span class="comment"> * Let A&lt;sub&gt;mn&lt;/sub&gt; and B&lt;sub&gt;np&lt;/sub&gt;:</span>
00203 <span class="comment"> * \f[</span>
00204 <span class="comment">    A · B = C / A_{mn} B_{np} = C_{mp} /</span>
00205 <span class="comment">    c_{ij} = \sum_{k=1}^n a_{ik} b_{kj}</span>
00206 <span class="comment">    (i = 1 \ldots m; j = 1 \ldots p)</span>
00207 <span class="comment">   \f]</span>
00208 <span class="comment"> *</span>
00209 <span class="comment"> * If p == 1 (i. e. B is a vector with a single column) then</span>
00210 <span class="comment"> * A · x for A&lt;sub&gt;mn&lt;/sub&gt; and x&lt;sub&gt;n1&lt;/sub&gt; is</span>
00211 <span class="comment"> * \f[</span>
<a name="l00212"></a><a class="code" href="mat__arith_8c.html#a2">00212</a> <span class="comment">    Y_{m1} / y_i = \sum_{k=1}^n a_{ik} x_k  (i = 1 \ldots m)</span>
00213 <span class="comment"> \f]</span>
00214 <span class="comment"> *</span>
00215 <span class="comment"> * \param prod  a matrix to store the resulting product</span>
00216 <span class="comment"> * \param fact1 first factor to multiply</span>
00217 <span class="comment"> * \param fact2 second factor matrix to multiply</span>
00218 <span class="comment"> *</span>
00219 <span class="comment"> *  \return SUCCESS if all went well, an error code otherwise</span>
00220 <span class="comment"> *</span>
00221 <span class="comment"> */</span>
00222 <span class="keyword">public</span> <a class="code" href="portable_8h.html#a78">status</a> <a class="code" href="mat__arith_8c.html#a2">mat_multiply</a>(<a class="code" href="structmatrix.html">matrix</a> prod, <a class="code" href="structmatrix.html">matrix</a> fact1, <a class="code" href="structmatrix.html">matrix</a> fact2)
00223 {
00224 <span class="preprocessor">#   ifdef MAT_PARANOIA</span>
00225 <span class="preprocessor"></span>    <span class="keywordflow">if</span> ((prod-&gt;<a class="code" href="structmatrix.html#m0">rows</a> != fact1-&gt;<a class="code" href="structmatrix.html#m0">rows</a>) ||
00226         (prod-&gt;<a class="code" href="structmatrix.html#m1">cols</a> != fact2-&gt;<a class="code" href="structmatrix.html#m1">cols</a>) || (fact1-&gt;<a class="code" href="structmatrix.html#m1">cols</a> != fact2-&gt;<a class="code" href="structmatrix.html#m0">rows</a>))
00227         <span class="keywordflow">return</span> <a class="code" href="matrix_8h.html#a2">MAT_BOUNDSCHECK</a>;
00228 <span class="preprocessor">#   endif</span>
00229 <span class="preprocessor"></span>    {
00230         <span class="keyword">auto</span> <span class="keywordtype">int</span> i, j, k;
00231         <span class="keyword">auto</span> <span class="keywordtype">int</span> m, n, p;
00232         <span class="keyword">auto</span> <a class="code" href="matrix_8h.html#a5">real</a> temp;
00233         <span class="keyword">auto</span> <a class="code" href="matrix_8h.html#a5">real</a> **p_vals, **f1_vals, **f2_vals;
00234         m = prod-&gt;<a class="code" href="structmatrix.html#m0">rows</a>;
00235         n = fact1-&gt;<a class="code" href="structmatrix.html#m1">cols</a>;
00236         p = fact2-&gt;<a class="code" href="structmatrix.html#m1">cols</a>;
00237         p_vals = prod-&gt;<a class="code" href="structmatrix.html#m2">values</a>;
00238         f1_vals = fact1-&gt;<a class="code" href="structmatrix.html#m2">values</a>;
00239         f2_vals = fact2-&gt;<a class="code" href="structmatrix.html#m2">values</a>;
00240 
00241         <span class="keywordflow">for</span> (i = 1; i &lt;= m; i++)
00242             <span class="keywordflow">for</span> (j = 1; j &lt;= p; j++) {
00243                 temp = 0.0;
00244                 <span class="keywordflow">for</span> (k = 1; k &lt;= n; k++)
00245                     temp += (f1_vals[i][k] * f2_vals[k][j]);
00246                 p_vals[i][j] = temp;
00247             }
00248     }
00249     <span class="keywordflow">return</span> <a class="code" href="portable_8h.html#a65">SUCCESS</a>;
00250 }
00251 
00252 <span class="comment"></span>
00253 <span class="comment">/**</span>
00254 <span class="comment"> *  \brief compute the scalar product </span>
00255 <span class="comment"> *</span>
<a name="l00256"></a><a class="code" href="mat__arith_8c.html#a3">00256</a> <span class="comment"> *  Compute the product of a matrix by a scalar quantity and store</span>
00257 <span class="comment"> * the result in another matrix: \f[</span>
00258 <span class="comment">    B = \lambda \cdot A (\lambda = constant)</span>
00259 <span class="comment">    \f]\f[</span>
00260 <span class="comment">    b_{ij} = \lambda \cdot a_{ij} (i = 1 \ldots m, j = 1 \ldots n)</span>
00261 <span class="comment"> \f]</span>
00262 <span class="comment"> *</span>
00263 <span class="comment"> * \param scprod    the matrix to store the result</span>
00264 <span class="comment"> * \param mat       the matrix to multiply</span>
00265 <span class="comment"> * \param lambda    the scalar operand</span>
00266 <span class="comment"> *</span>
00267 <span class="comment"> *  \return SUCCESS if all went well, an error code otherwise</span>
00268 <span class="comment"> *</span>
00269 <span class="comment"> */</span>
00270 <span class="keyword">public</span> <a class="code" href="portable_8h.html#a78">status</a> <a class="code" href="mat__arith_8c.html#a3">mat_scalar_product</a>(<a class="code" href="structmatrix.html">matrix</a> scprod, <a class="code" href="structmatrix.html">matrix</a> mat, <a class="code" href="matrix_8h.html#a5">real</a> lambda)
00271 {
00272 <span class="preprocessor">#ifndef MAT_OPTIMIZE</span>
00273 <span class="preprocessor"></span>    <span class="keyword">register</span> <span class="keywordtype">int</span> i, j;
00274 
00275     <span class="keywordflow">for</span> (i = 1; i &lt;= mat-&gt;<a class="code" href="structmatrix.html#m0">rows</a>; i++)
00276         <span class="keywordflow">for</span> (j = 1; j &lt;= mat-&gt;<a class="code" href="structmatrix.html#m1">cols</a>; j++)
00277             scprod-&gt;<a class="code" href="structmatrix.html#m2">values</a>[i][j] = mat-&gt;<a class="code" href="structmatrix.html#m2">values</a>[i][j] * lambda;
00278 <span class="preprocessor">#else</span>
00279 <span class="preprocessor"></span>    <span class="keyword">register</span> <span class="keywordtype">int</span> i, size;
00280     <span class="keyword">register</span> <a class="code" href="matrix_8h.html#a5">real</a> *result, *val;
00281 
00282     <span class="comment">/* we know all rows were allocated contiguously starting</span>
00283 <span class="comment">     * at mat-&gt;values[1] hence we may save on pointer indirections */</span>
00284     size = mat-&gt;<a class="code" href="structmatrix.html#m0">rows</a> * mat-&gt;<a class="code" href="structmatrix.html#m1">cols</a>;
00285     result = scprod-&gt;<a class="code" href="structmatrix.html#m2">values</a>[1];
00286     val = mat-&gt;<a class="code" href="structmatrix.html#m2">values</a>[1];
00287     <span class="keywordflow">for</span> (i = 1; i &lt;= size; i++)
00288         result[i] = val[i] * lambda;
00289 
00290 <span class="preprocessor">#endif</span>
00291 <span class="preprocessor"></span>}
00292 
00293 <span class="comment"></span>
00294 <span class="comment">/** @} */</span>
</pre></div><hr><address style="align: right;"><small>Generated on Fri Mar 5 19:26:48 2004 for MATRIXCALCULUS by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.18 </small></address>
</body>
</html>
